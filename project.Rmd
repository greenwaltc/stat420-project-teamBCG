---
title: "Predicting Grain Crop Yields in India for Years 1997 - 2020"
output: html_document
date: "2023-07-31"
author: "Team BCG: Cameron Greenwalt, Mark Bauer, Ben Carman"
---

---- 

```{r}
# TODO: run inference on test dataset - Mark
# TODO: Actually write the document - Mark
# TODO: Create summary information table of models for both training and test datasets - Mark
# todo: Try Crop_Year as both continuous, categorical, and excluded and compare results
```


# Helper functions

```{r}
plot_fitted_resid <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  plot(fitted(model), resid(model),
    col = pointcol, pch = 20, cex = 1.5,
    xlab = "Fitted", ylab = "Residuals", main = "Fitted vs. Residuals"
  )
  abline(h = 0, col = linecol, lwd = 2)
}

plot_qq <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  qqnorm(resid(model), col = pointcol, pch = 20, cex = 1.5)
  qqline(resid(model), col = linecol, lwd = 2)
}

plot_fitted_v_actual <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  set_plot_grid(1, 1)
  plot(fitted(model), resid(model) + fitted(model),
    col = pointcol, pch = 20, cex = 1.5,
    xlab = "Fitted", ylab = "Actual", main = "Fitted vs. Actual"
  )
  lines(x = fitted(model), y = fitted(model), col = linecol, lwd = 2)
}

set_plot_grid <- function(nrow = 1, ncol = 1) {
  par(mfrow = c(nrow, ncol))
}

assumptions_plots <- function(model) {
  set_plot_grid(1, 3)
  plot_fitted_resid(model)
  plot_qq(model)
  hist(resid(model), main = "Histogram of Model Residuals", xlab = "Residuals")
}

plot_cooksd <- function(model) {
  set_plot_grid(1, 1)
  cooksd <- cooks.distance(model)
  n <- length(model$residuals)
  infl <- cooksd > (4 / n)
  plot(1:n,
    cooksd,
    col = ifelse(infl == 1, "red", "black"),
    xlab = "Sample Index",
    ylab = "Cook's Distance",
    main = "Cook's Distances"
  )
  abline(
    h = 4 / n,
    col = "royalblue"
  )
}

bc_transform <- function(x, lambda) {
  (x^lambda - 1) / lambda
}

get_loocv_rmse <- function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model)))^2))
}

get_adj_r2 <- function(model) {
  summary(model)$adj.r.squared
}

remove_infl_pts <- function(model, data) {
  infl_pt_idx <- cooks.distance(baseline) > 4 / nrow(crops.train)
  data[-infl_pt_idx, ]
}

output_diagnostics = function(model, vif = TRUE) {
  if (length(coef(model)) < 30) {
    print("Model Summary:")
    print(summary(model))
  }
  plot_fitted_v_actual(model)
  assumptions_plots(model)
  plot_cooksd(model)
  bptest(model)
  shapiro.test(resid(model))
  
  print(c("LOOCV-RMSE:", get_loocv_rmse(model)))
  
  if (vif) {
    car::vif(model)
  }
}
```

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(plyr)
library(car)
library(glmnet)
library(MASS)
library(lmtest)
library(coefplot)
```

## Introduction

In this project we will explore our ability to predict yields of grain crops in India based on some information about the land in which they were grown on (field size, general region), the type of grain, inputs used (fertilizer, pesticide), and weather (season, rain). 

```{r message=FALSE}
crops <- read_csv("crop_yield.csv")
```

Here we provide a summary or the data, which can be found (here)[https://www.kaggle.com/datasets/akshatgupta7/crop-yield-in-indian-states-dataset].  

Response - Production: The quantity of crop production (in metric tons).

Predictors

- Crop: The name of the cultivated crop .  
- Crop_Year: The year in which the crop was grown.
- Season: The specific cropping season (e.g., Kharif, Rabi, Whole Year).
- State: The Indian state where the crop was cultivated.
- Area: The total land area (in hectares) under cultivation for the specific crop.
- Annual_Rainfall: The annual rainfall received in the crop-growing region (in mm).
- Fertilizer: The total amount of fertilizer used for the crop (in kilograms).
- Pesticide: The total amount of pesticide used for the crop (in kilograms).

It turns our original intended response, `Yield`, is a metric derived by computing `Production / Area`. It would be incorrect for us to include `Production` and `Area` as predictors in a model whose response is `Yield`. Instead, we remove `Yield` and use the remaining variables to predict `Production`.

```{r}
crops <- crops[, !(names(crops) %in% c("Yield"))]
```

In order to limit scope, we also limit the types of crops under observation to a subset of grains (e.g., wheat, barley, rye, etc.). We also convert categorical variables to factor variables as appropriate.

```{r message=FALSE, warning=FALSE}
grains <- c(
  "Amaranth", "Barley", "Bulgur", "Corn", "Farro", "Einkorn", "Emmer",
  "Spelt", "Millet", "Freaked", "Farik", "Durum Wheat",
  "Khorasan Wheat", "Oats", "Quinoa", "Kana", "Rice", "Rye",
  "Sorghum", "Teff", "Triticale", "Wheat", "Wild Rice", "Wheat",
  "Wheat berries", "Hominy", "Spelt", "Rye", "Brown Rice", "Farro",
  "Emmer", "Barley", "Bran", "Durum Wheat ", "Triticale",
  "Bulgur Wheat", "Couscous", "Farina", "Kamut", "Orzo", "Semolina",
  "Graham", "Oats", "Corn", "maize", "Cornflour ", "Cornmeal", "Rice",
  "Wild Rice", "Teff", "Montina flour", "Sorghum", "Oats", "Freekeh",
  "Emmer", "Eikorn", "Malt", "Graham", "Couscous", "Polenta", "Muesli",
  "Seitan", "Panko", "Grain Alcohol", "Atta Flour", "Amaranth", "Quinoa",
  "Millet", "Barley Malt", "Beer", "Bleached Flour", "Breads",
  "Baked Goods", "Brown Rice Syrup", "Buckwheat", "Corn Flakes",
  "Croutons", "Cereals", "Wheat Germ", "Enriched Bleach Flour",
  "Malted Barley Flour", "Millet", "Granary Flour", "Groats",
  "Pastas", "Matzo", "Rice Milk", "Seitan", "Tabbouleh", "Udon",
  "Corn Starch", "Wheat nuts", "Other Cereals"
)

# Drop non-grain rows
crops <- crops[str_squish(tolower(crops$Crop)) %in% str_squish(tolower(grains)), ]

# Convert categorical variables to factor variables
crops$Crop <- as.factor(crops$Crop)
crops$Season <- as.factor(crops$Season)
crops$State <- as.factor(crops$State)
crops$Crop_Year = as.factor(crops$Crop_Year)

levels(crops$Crop)
```

Here we present a few rows from the cleaned and pared down dataset:

```{r}
kable(
  head(crops, 5)
)
```

As we prepare the dataset for modeling, we also explore the remaining factor variables:

```{r}
levels(crops$Season)
```

The season column appears reasonable. Let's also check the values for State:

```{r}
levels(crops$State)
```

In order to keep our model's complexity minimal, we will pre-process the data to consider zones in India instead of working at the granularity of individual states:

```{r}
# See https://en.wikipedia.org/wiki/Administrative_divisions_of_India

states_to_zones <- c(
  "Chandigarh" = "Northern",
  "Delhi" = "Northern",
  "Haryana" = "Northern",
  "Himachal Pradesh" = "Northern",
  "Jammu and Kashmir" = "Northern",
  "Ladakh" = "Northern",
  "Punjab" = "Northern",
  "Rajasthan" = "Northern",
  "Assam" = "North Eastern",
  "Arunachal Pradesh" = "North Eastern",
  "Manipur" = "North Eastern",
  "Meghalaya" = "North Eastern",
  "Mizoram" = "North Eastern",
  "Nagaland" = "North Eastern",
  "Tripura" = "North Eastern",
  "Sikkim" = "North Eastern",
  "Chhattisgarh" = "Central",
  "Madhya Pradesh" = "Central",
  "Uttarakhand" = "Central",
  "Uttar Pradesh" = "Central",
  "Bihar" = "Eastern",
  "Jharkhand" = "Eastern",
  "Odisha" = "Eastern",
  "West Bengal" = "Eastern",
  "Goa" = "Western",
  "Gujarat" = "Western",
  "Maharashtra" = "Western",
  "Andhra Pradesh" = "Southern",
  "Karnataka" = "Southern",
  "Kerala" = "Southern",
  "Puducherry" = "Southern",
  "Tamil Nadu" = "Southern",
  "Telangana" = "Southern"
)


crops$State <- revalue(crops$State, states_to_zones)
names(crops)[which(names(crops) == "State")] <- "Zone"
crops$Zone <- as.factor(crops$Zone)
levels(crops$Zone)
```

```{r fig.height=5, fig.width=10}
vars.res <- "Production"
vars.con <- c("Area", "Annual_Rainfall", "Fertilizer", "Pesticide")
vars.cat <- c("Crop", "Season", "Zone", "Crop_Year")
```

## Methods

Starting off, we do some exploration of the data, prepare train and test splits, and address problematic data.  

```{r}
set.seed(0)

nrow(crops)

sample <- sample(c(TRUE, FALSE), nrow(crops), replace = TRUE, prob = c(0.8, 0.2))
crops.train <- crops[sample, ]
crops.test <- crops[!sample, ]

nrow(crops.train)
nrow(crops.test)
```

```{r}
pairs(crops.train[, c(vars.con, vars.res)])
```

Next, we create a baseline additive model with all predictors.

```{r fig.height=5, fig.width=8}
baseline <- lm(Production ~ ., data = crops.train)
output_diagnostics(baseline)
```

# Todo: Add code to show the influential point and warrant removal

Remove that one super influential point

```{r fig.height=5, fig.width=8}
infl_pt_idx <- cooks.distance(baseline) > 4 / nrow(crops.train)
idx_remove <- which.max(cooks.distance(baseline))
crops.train.no_infl <- crops.train[-idx_remove, ]

baseline.no_infl <- lm(Production ~ ., data = crops.train.no_infl)
output_diagnostics(baseline.no_infl)
```


```{r fig.height=5, fig.width=8}
# See https://www.statology.org/box-cox-transformation-in-r/

# Define plotting area
set_plot_grid(1, 2)

# Box-cox requires that the response be positive (0 doesn't work), so we add
# 1 here (just need to remember to subtract 1 when giving actual predictions)
baseline <- lm(I(Production + 1) ~ ., data = crops.train)

bc <- boxcox(baseline)
(lambda <- bc$x[which.max(bc$y)])

baseline.bc <- lm(bc_transform(Production, lambda) ~ ., data = crops.train)
output_diagnostics(baseline.bc)
```

***

```{r}
# continuous-categorical interactions
baseline.poly.form = as.formula(Production + 1 ~ 
                        (poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1)) *
                        (Crop + Season + Zone + Crop_Year))
baseline.poly = lm(baseline.poly.form, data = crops.train)
output_diagnostics(baseline.poly, vif = 0)
```

```{r}
crops.train.poly.no_infl <- remove_infl_pts(baseline.poly, crops.train)

baseline.poly = lm(baseline.poly.form, data = crops.train.poly.no_infl)
output_diagnostics(baseline.poly, vif = 0)
```

```{r}
bc <- boxcox(baseline.poly)
(lambda <- bc$x[which.max(bc$y)])

baseline.poly.bc = lm(paste("bc_transform(Production + 1, lambda) ~ ", 
                             paste(attr(terms(baseline.poly.form), 
                                        which = "term.labels"), 
                                   collapse = " + ")),
                        data = crops.train.poly.no_infl)
output_diagnostics(baseline.poly.bc, vif = 0)
```

***
```{r}
baseline.multi.form = as.formula(Production + 1 ~ 
                        (poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1) +
                        I(sqrt(Area)) +
                        I(sqrt(Annual_Rainfall)) +
                        I(sqrt(Fertilizer)) +
                        I(sqrt(Pesticide)) +
                        I(log(Area)) +
                        I(log(Annual_Rainfall)) +
                        I(log(Fertilizer)) +
                        I(log(Pesticide))) *
                        (Crop + Season + Zone + Crop_Year))
baseline.multi = lm(baseline.multi.form, data = crops.train)
output_diagnostics(baseline.multi, vif = FALSE)
```

```{r}
# TODO: I've removed all the influential points here. We may not want to do that.
# In which case, we can remove this cell and use the model from the previous cell
# to do the box-cox transformation in the following cell.
crops.train.multi.no_infl <- remove_infl_pts(baseline.multi, crops.train)

baseline.multi = lm(baseline.multi.form, data = crops.train.multi.no_infl)
output_diagnostics(baseline.multi, vif = FALSE)
```

```{r}
bc <- boxcox(baseline.multi)
(lambda <- bc$x[which.max(bc$y)])

baseline.multi.bc = lm(paste("bc_transform(Production + 1, lambda) ~ ",
                             paste(attr(terms(baseline.multi.form),
                                        which = "term.labels"),
                                   collapse = " + ")),
                        data = crops.train.multi.no_infl)
output_diagnostics(baseline.multi.bc, vif = FALSE)
```

***

```{r}
model.aic.backward <- step(baseline.multi.bc, direction = "backward", trace = 0)
output_diagnostics(model.aic.backward, vif = 0)
```

```{r}
model.bic.backward <- step(baseline.multi.bc,
  direction = "backward", trace = 0,
  k = log(nrow(crops.train.multi.no_infl))
)
output_diagnostics(model.bic.backward, vif = 0)
```


```{r}
f <- as.formula(paste("bc_transform(Production + 1, lambda) ~ ",
           paste(attr(terms(baseline.multi.form),
                      which = "term.labels"),
                 collapse = " + ")))
y <- crops.train.multi.no_infl$Production
x <- (model.matrix(f, crops.train.multi.no_infl))
model.lasso.cv <- cv.glmnet(x, y, alpha = 1, parallel = 1)
best_lambda <- model.lasso.cv$lambda.min
plot(model.lasso.cv)

best_model <- glmnet(x, y, alpha = 1, lambda = best_lambda)
# coef(best_model)

# extract.coef(model.lasso.cv)
(names = rownames(coef(best_model, s = 'lambda.min'))[coef(best_model, s = 'lambda.min')[,1]!= 0]) ### returns nonzero coefs
```

```{r}
predict(best_model, newx = x)
bc_transform(crops.train.multi.no_infl$Production + 1, lambda)
```

## Results

Here we summarize results for the following models explored above:

### TODO: Double check models/names used in this section, add models for other ways of representing "Year" in model
```{r}
models = list(baseline.multi, baseline.multi.bc, model.aic.backward, model.bic.backward)
modelNames = c("baseline.multi", "baseline.multi.bc", "model.aic.backward", "model.bic.backward")
```

To begin, we will assess each model's test performance using LOOCV-RMSE:

```{r}
loocv_rmses = rep(0,length(models))
for (i in 1:length(models)) {
  loocv_rmses[i] = get_loocv_rmse(models[[i]])
}

kable(data.frame("Model" = modelNames, "LOOCV-RMSE" = loocv_rmses))
```






