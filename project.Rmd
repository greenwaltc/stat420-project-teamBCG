---
title: "Predicting Grain Crop Yields in India for Years 1997 - 2020"
output: html_document
date: "2023-07-31"
---

```{r}
# TODO: Write function to output all model diagnostics and plots - Ben

#   summary(model)
#   plot_fitted_v_actual(model)
#   assumptions_plots(model)
#   plot_cooksd(model)
#   car::vif(model) ?? maybe

# TODO: Run CV validation of models - Ben
# TODO: run inference on test dataset - Mark
# TODO: Actually write the document - Mark
# TODO: Create summary information table of models for both training and test datasets - Mark

# todo: Try Crop_Year as both continuous, categorical, and excluded and compare results
```


---
# Helper functions

```{r}
plot_fitted_resid <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  plot(fitted(model), resid(model),
    col = pointcol, pch = 20, cex = 1.5,
    xlab = "Fitted", ylab = "Residuals", main = "Fitted vs. Residuals"
  )
  abline(h = 0, col = linecol, lwd = 2)
}

plot_qq <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  qqnorm(resid(model), col = pointcol, pch = 20, cex = 1.5)
  qqline(resid(model), col = linecol, lwd = 2)
}

plot_fitted_v_actual <- function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  set_plot_grid(1, 1)
  plot(fitted(model), resid(model) + fitted(model),
    col = pointcol, pch = 20, cex = 1.5,
    xlab = "Fitted", ylab = "Actual", main = "Fitted vs. Actual"
  )
  lines(x = fitted(model), y = fitted(model), col = linecol, lwd = 2)
}

set_plot_grid <- function(nrow = 1, ncol = 1) {
  par(mfrow = c(nrow, ncol))
}

assumptions_plots <- function(model) {
  set_plot_grid(1, 3)
  plot_fitted_resid(model)
  plot_qq(model)
  hist(resid(model), main = "Histogram of Model Residuals", xlab = "Residuals")
}

plot_cooksd <- function(model) {
  set_plot_grid(1, 1)
  cooksd <- cooks.distance(model)
  n <- length(model$residuals)
  infl <- cooksd > (4 / n)
  plot(1:n,
    cooksd,
    col = ifelse(infl == 1, "red", "black"),
    xlab = "Sample Index",
    ylab = "Cook's Distance",
    main = "Cook's Distances"
  )
  abline(
    h = 4 / n,
    col = "royalblue"
  )
}

bc_transform <- function(x, lambda) {
  (x^lambda - 1) / lambda
}

get_loocv_rmse <- function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model)))^2))
}

get_adj_r2 <- function(model) {
  summary(model)$adj.r.squared
}

remove_infl_pts <- function(model, data) {
  infl_pt_idx <- cooks.distance(baseline) > 4 / nrow(crops.train)
  data[-infl_pt_idx, ]
}
```

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(plyr)
library(car)
library(glmnet)
library(MASS)
library(lmtest)
library(coefplot)
```

## Introduction

Below we will explore our ability to predict yields of grain crops in India based on some information about the land in which they were grown on (field size, general region), the type of grain, inputs used (fertilizer, pesticide), and weather (season, rain).  

```{r message=FALSE}
crops <- read_csv("crop_yield.csv")
```

It turns out that original intended response, `Yield`, is a metric derived by computing `Production / Area`. It would be incorrect for us to include `Production` and `Area` as predictors in a model whose response is `Yield`. Instead, we will remove `Yield` and use the remaining variables to predict `Production`.

```{r}
crops <- crops[, !(names(crops) %in% c("Yield"))]
```



```{r message=FALSE, warning=FALSE}
grains <- c(
  "Amaranth", "Barley", "Bulgur", "Corn", "Farro", "Einkorn", "Emmer",
  "Spelt", "Millet", "Freaked", "Farik", "Durum Wheat",
  "Khorasan Wheat", "Oats", "Quinoa", "Kana", "Rice", "Rye",
  "Sorghum", "Teff", "Triticale", "Wheat", "Wild Rice", "Wheat",
  "Wheat berries", "Hominy", "Spelt", "Rye", "Brown Rice", "Farro",
  "Emmer", "Barley", "Bran", "Durum Wheat ", "Triticale",
  "Bulgur Wheat", "Couscous", "Farina", "Kamut", "Orzo", "Semolina",
  "Graham", "Oats", "Corn", "maize", "Cornflour ", "Cornmeal", "Rice",
  "Wild Rice", "Teff", "Montina flour", "Sorghum", "Oats", "Freekeh",
  "Emmer", "Eikorn", "Malt", "Graham", "Couscous", "Polenta", "Muesli",
  "Seitan", "Panko", "Grain Alcohol", "Atta Flour", "Amaranth", "Quinoa",
  "Millet", "Barley Malt", "Beer", "Bleached Flour", "Breads",
  "Baked Goods", "Brown Rice Syrup", "Buckwheat", "Corn Flakes",
  "Croutons", "Cereals", "Wheat Germ", "Enriched Bleach Flour",
  "Malted Barley Flour", "Millet", "Granary Flour", "Groats",
  "Pastas", "Matzo", "Rice Milk", "Seitan", "Tabbouleh", "Udon",
  "Corn Starch", "Wheat nuts", "Other Cereals"
)

# Other grain types may be added later
crops <- crops[str_squish(tolower(crops$Crop)) %in% str_squish(tolower(grains)), ]

crops$Crop <- as.factor(crops$Crop)
crops$Season <- as.factor(crops$Season)
crops$State <- as.factor(crops$State)
crops$Crop_Year = as.factor(crops$Crop_Year)

levels(crops$Crop)

# Drop rows with NA. We are trading rigor for simplicity here.
crops <- na.omit(crops)
```

A quick description of the data, which can be found (here)[https://www.kaggle.com/datasets/akshatgupta7/crop-yield-in-indian-states-dataset].  

Response - Yield: The calculated crop yield (production per unit area)

Predictors
* Crop: The name of the cultivated crop .  
* Crop_Year: The year in which the crop was grown.
* Season: The specific cropping season (e.g., Kharif, Rabi, Whole Year).
* State: The Indian state where the crop was cultivated.
* Area: The total land area (in hectares) under cultivation for the specific crop.
* Production: The quantity of crop production (in metric tons).
* Annual_Rainfall: The annual rainfall received in the crop-growing region (in mm).
* Fertilizer: The total amount of fertilizer used for the crop (in kilograms).
* Pesticide: The total amount of pesticide used for the crop (in kilograms).

```{r}
kable(
  head(crops, 5)
)
```

```{r}
levels(crops$Season)
```

```{r}
levels(crops$State)

# See https://en.wikipedia.org/wiki/Administrative_divisions_of_India

states_to_zones <- c(
  "Chandigarh" = "Northern",
  "Delhi" = "Northern",
  "Haryana" = "Northern",
  "Himachal Pradesh" = "Northern",
  "Jammu and Kashmir" = "Northern",
  "Ladakh" = "Northern",
  "Punjab" = "Northern",
  "Rajasthan" = "Northern",
  "Assam" = "North Eastern",
  "Arunachal Pradesh" = "North Eastern",
  "Manipur" = "North Eastern",
  "Meghalaya" = "North Eastern",
  "Mizoram" = "North Eastern",
  "Nagaland" = "North Eastern",
  "Tripura" = "North Eastern",
  "Sikkim" = "North Eastern",
  "Chhattisgarh" = "Central",
  "Madhya Pradesh" = "Central",
  "Uttarakhand" = "Central",
  "Uttar Pradesh" = "Central",
  "Bihar" = "Eastern",
  "Jharkhand" = "Eastern",
  "Odisha" = "Eastern",
  "West Bengal" = "Eastern",
  "Goa" = "Western",
  "Gujarat" = "Western",
  "Maharashtra" = "Western",
  "Andhra Pradesh" = "Southern",
  "Karnataka" = "Southern",
  "Kerala" = "Southern",
  "Puducherry" = "Southern",
  "Tamil Nadu" = "Southern",
  "Telangana" = "Southern"
)


crops$State <- revalue(crops$State, states_to_zones)
names(crops)[which(names(crops) == "State")] <- "Zone"
crops$Zone <- as.factor(crops$Zone)
levels(crops$Zone)
```

```{r fig.height=5, fig.width=10}
vars.res <- "Production"
vars.con <- c("Area", "Annual_Rainfall", "Fertilizer", "Pesticide")
vars.cat <- c("Crop", "Season", "Zone", "Crop_Year")
```

## Methods

Starting off, we do some exploration of the data, prepare train and test splits, and address problematic data.  

```{r}
set.seed(0)

nrow(crops)

sample <- sample(c(TRUE, FALSE), nrow(crops), replace = TRUE, prob = c(0.8, 0.2))
crops.train <- crops[sample, ]
crops.test <- crops[!sample, ]

nrow(crops.train)
nrow(crops.test)
```

```{r}
pairs(crops.train[, c(vars.con, vars.res)])
```

Next, we create a baseline additive model with all predictors.

```{r fig.height=5, fig.width=8}
baseline <- lm(Production ~ ., data = crops.train)
summary(baseline)
plot_fitted_v_actual(baseline)
assumptions_plots(baseline)
plot_cooksd(baseline)
car::vif(baseline)
get_loocv_rmse(baseline)
```

# Todo: Add code to show the influential point and warrant removal

Remove that one super influential point

```{r fig.height=5, fig.width=8}
infl_pt_idx <- cooks.distance(baseline) > 4 / nrow(crops.train)
idx_remove <- which.max(cooks.distance(baseline))
crops.train.no_infl <- crops.train[-idx_remove, ]

baseline.no_infl <- lm(Production ~ ., data = crops.train.no_infl)
summary(baseline.no_infl)
plot_fitted_v_actual(baseline.no_infl)
assumptions_plots(baseline.no_infl)
plot_cooksd(baseline.no_infl)
get_loocv_rmse(baseline.no_infl)
```


```{r fig.height=5, fig.width=8}
# See https://www.statology.org/box-cox-transformation-in-r/

# Define plotting area
set_plot_grid(1, 2)

# Box-cox requires that the response be positive (0 doesn't work), so we add
# 1 here (just need to remember to subtract 1 when giving actual predictions)
baseline <- lm(I(Production + 1) ~ ., data = crops.train)

bc <- boxcox(baseline)
(lambda <- bc$x[which.max(bc$y)])

baseline.bc <- lm(bc_transform(Production, lambda) ~ ., data = crops.train)

assumptions_plots(baseline.bc)

bptest(baseline.bc)
shapiro.test(resid(baseline.bc))
```

***

```{r}
# continuous-categorical interactions
baseline.poly.form = as.formula(Production + 1 ~ 
                        (poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1)) *
                        (Crop + Season + Zone + Crop_Year))
baseline.poly = lm(baseline.poly.form, data = crops.train)
summary(baseline.poly)
plot_fitted_v_actual(baseline.poly)
assumptions_plots(baseline.poly)
plot_cooksd(baseline.poly)
get_loocv_rmse(baseline.poly)
bptest(baseline.poly)
shapiro.test(resid(baseline.poly))
```

```{r}
crops.train.poly.no_infl <- remove_infl_pts(baseline.poly, crops.train)

baseline.poly = lm(baseline.poly.form, data = crops.train.poly.no_infl)
summary(baseline.poly)
plot_fitted_v_actual(baseline.poly)
assumptions_plots(baseline.poly)
plot_cooksd(baseline.poly)
get_loocv_rmse(baseline.poly)
bptest(baseline.poly)
shapiro.test(resid(baseline.poly))
```

```{r}
bc <- boxcox(baseline.poly)
(lambda <- bc$x[which.max(bc$y)])

baseline.poly.bc = lm(paste("bc_transform(Production + 1, lambda) ~ ", 
                             paste(attr(terms(baseline.poly.form), 
                                        which = "term.labels"), 
                                   collapse = " + ")),
                        data = crops.train.poly.no_infl)

summary(baseline.poly.bc)
plot_fitted_v_actual(baseline.poly.bc)
assumptions_plots(baseline.poly.bc)
plot_cooksd(baseline.poly.bc)
get_loocv_rmse(baseline.poly.bc)
bptest(baseline.poly.bc)
shapiro.test(resid(baseline.poly.bc))
```

***
```{r}
baseline.multi.form = as.formula(Production + 1 ~ 
                        (poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1) +
                        I(sqrt(Area)) +
                        I(sqrt(Annual_Rainfall)) +
                        I(sqrt(Fertilizer)) +
                        I(sqrt(Pesticide)) +
                        I(log(Area)) +
                        I(log(Annual_Rainfall)) +
                        I(log(Fertilizer)) +
                        I(log(Pesticide))) *
                        (Crop + Season + Zone + Crop_Year))
baseline.multi = lm(baseline.multi.form, data = crops.train)
summary(baseline.multi)
plot_fitted_v_actual(baseline.multi)
assumptions_plots(baseline.multi)
plot_cooksd(baseline.multi)
get_loocv_rmse(baseline.multi)
bptest(baseline.multi)
shapiro.test(resid(baseline.multi))
```

```{r}
# TODO: I've removed all the influential points here. We may not want to do that.
# In which case, we can remove this cell and use the model from the previous cell
# to do the box-cox transformation in the following cell.
crops.train.multi.no_infl <- remove_infl_pts(baseline.multi, crops.train)

baseline.multi = lm(baseline.multi.form, data = crops.train.multi.no_infl)
summary(baseline.multi)
plot_fitted_v_actual(baseline.multi)
assumptions_plots(baseline.multi)
plot_cooksd(baseline.multi)
get_loocv_rmse(baseline.multi)
bptest(baseline.multi)
shapiro.test(resid(baseline.multi))
```

```{r}
bc <- boxcox(baseline.multi)
(lambda <- bc$x[which.max(bc$y)])

baseline.multi.bc = lm(paste("bc_transform(Production + 1, lambda) ~ ",
                             paste(attr(terms(baseline.multi.form),
                                        which = "term.labels"),
                                   collapse = " + ")),
                        data = crops.train.multi.no_infl)

summary(baseline.multi.bc)
plot_fitted_v_actual(baseline.multi.bc)
assumptions_plots(baseline.multi.bc)
plot_cooksd(baseline.multi.bc)
get_loocv_rmse(baseline.multi.bc)
bptest(baseline.multi.bc)
shapiro.test(resid(baseline.multi.bc))
```


***

```{r}
model.aic.backward <- step(baseline.multi.bc, direction = "backward", trace = 0)
summary(model.aic.backward)
plot_fitted_v_actual(model.aic.backward)
assumptions_plots(model.aic.backward)
plot_cooksd(model.aic.backward)
get_loocv_rmse(model.aic.backward)
bptest(model.aic.backward)
shapiro.test(resid(model.aic.backward))
```

```{r}
model.bic.backward <- step(baseline.multi.bc,
  direction = "backward", trace = 0,
  k = log(nrow(crops.train.poly.no_infl))
)
summary(model.bic.backward)
plot_fitted_v_actual(model.bic.backward)
assumptions_plots(model.bic.backward)
plot_cooksd(model.bic.backward)
get_loocv_rmse(model.bic.backward)
bptest(model.bic.backward)
shapiro.test(resid(model.bic.backward))
```


```{r}
f <- as.formula(paste("bc_transform(Production + 1, lambda) ~ ",
           paste(attr(terms(baseline.multi.form),
                      which = "term.labels"),
                 collapse = " + ")))
y <- crops$Production
x <- (model.matrix(f, crops))
model.lasso.cv <- cv.glmnet(x, y, alpha = 1, parallel = 1)
best_lambda <- model.lasso.cv$lambda.min
plot(model.lasso.cv)

best_model <- glmnet(x, y, alpha = 1, lambda = best_lambda)
coef(best_model)

extract.coef(model.lasso.cv)

# summary(best_model)
# plot_fitted_v_actual(best_model)
# assumptions_plots(best_model)
# plot_cooksd(best_model)
# get_loocv_rmse(best_model)
# bptest(best_model)
# shapiro.test(resid(best_model))
```
