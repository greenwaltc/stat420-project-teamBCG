---
title: "Predicting Grain Crop Yields in India for Years 1997 - 2020"
output: html_document
date: "2023-07-31"
---

---
# Helper functions

```{r}
plot_fitted_resid = function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  plot(fitted(model), resid(model), 
       col = pointcol, pch = 20, cex = 1.5,
       xlab = "Fitted", ylab = "Residuals", main = "Fitted vs. Residuals")
  abline(h = 0, col = linecol, lwd = 2)
}

plot_qq = function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  qqnorm(resid(model), col = pointcol, pch = 20, cex = 1.5)
  qqline(resid(model), col = linecol, lwd = 2)
}

plot_fitted_v_actual = function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  set_plot_grid(1,1)
  plot(fitted(model), resid(model) + fitted(model), 
       col = pointcol, pch = 20, cex = 1.5,
       xlab = "Fitted", ylab = "Actual", main = "Fitted vs. Actual")
  lines(x = fitted(model), y = fitted(model), col = linecol, lwd = 2)
}

set_plot_grid = function(nrow = 1, ncol = 1) {
  par(mfrow = c(nrow, ncol))
}

assumptions_plots = function(model) {
  set_plot_grid(1, 3)
  plot_fitted_resid(model)
  plot_qq(model)
  hist(resid(model), main = "Histogram of Model Residuals", xlab = "Residuals")
}

plot_cooksd = function(model) {
  set_plot_grid(1,1)
  cooksd = cooks.distance(model)
  n = length(model$residuals)
  infl = cooksd > (4 / n)
  plot(1:n, 
       cooksd, 
       col = ifelse(infl == 1, "red", "black"),
       xlab = "Sample Index",
       ylab = "Cook's Distance",
       main = "Cook's Distances")
  abline(h = 4 / n,
         col = "royalblue")
  text(x = 10, y = (4/n), "4/n cutoff")
}

bc_transform = function(x, lambda) {
  (x^lambda-1)/lambda
}

get_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}

remove_infl_pts = function(model, data) {
  infl_pt_idx = cooks.distance(baseline) > 4 / nrow(crops.train)
  data[-infl_pt_idx,]
}
```

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(plyr)
library(car)
library(glmnet)
library(MASS)
library(lmtest)
```

## Introduction

Below we will explore our ability to predict yields of grain crops in India based on some information about the land in which they were grown on (field size, general region), the type of grain, inputs used (fertilizer, pesticide), and weather (season, rain).  

```{r message=FALSE}
crops = read_csv("crop_yield.csv")
```

It turns out that original intended response, `Yield`, is a metric derived by computing `Production / Area`. It would be incorrect for us to include `Production` and `Area` as predictors in a model whose response is `Yield`. Instead, we will remove `Yield` and use the remaining variables to predict `Production`.

```{r}
crops = crops[,!(names(crops) %in% c("Yield"))]
```



```{r message=FALSE, warning=FALSE}

grains = c( "Amaranth", "Barley", "Bulgur", "Corn", "Farro", "Einkorn", "Emmer",
            "Spelt", "Millet", "Freaked", "Farik", "Durum Wheat", 
            "Khorasan Wheat", "Oats", "Quinoa", "Kana", "Rice", "Rye", 
            "Sorghum", "Teff", "Triticale", "Wheat", "Wild Rice", "Wheat", 
            "Wheat berries", "Hominy", "Spelt", "Rye", "Brown Rice", "Farro", 
            "Emmer", "Barley", "Bran", "Durum Wheat ", "Triticale", 
            "Bulgur Wheat", "Couscous", "Farina", "Kamut", "Orzo", "Semolina", 
            "Graham", "Oats", "Corn", "maize", "Cornflour ", "Cornmeal", "Rice", 
            "Wild Rice", "Teff", "Montina flour", "Sorghum", "Oats", "Freekeh", 
            "Emmer", "Eikorn", "Malt", "Graham", "Couscous", "Polenta", "Muesli", 
            "Seitan", "Panko", "Grain Alcohol", "Atta Flour", "Amaranth", "Quinoa", 
            "Millet", "Barley Malt", "Beer", "Bleached Flour", "Breads", 
            "Baked Goods", "Brown Rice Syrup", "Buckwheat", "Corn Flakes", 
            "Croutons", "Cereals", "Wheat Germ", "Enriched Bleach Flour", 
            "Malted Barley Flour", "Millet", "Granary Flour", "Groats", 
            "Pastas", "Matzo", "Rice Milk", "Seitan", "Tabbouleh", "Udon", 
            "Corn Starch", "Wheat nuts", "Other Cereals"
)

# Other grain types may be added later
crops = crops[str_squish(tolower(crops$Crop)) %in% str_squish(tolower(grains)),]

crops$Crop = as.factor(crops$Crop)
crops$Season = as.factor(crops$Season)
crops$State = as.factor(crops$State)

levels(crops$Crop)

# Drop rows with NA. We are trading rigor for simplicity here.  
crops = na.omit(crops)
```

A quick description of the data, which can be found (here)[https://www.kaggle.com/datasets/akshatgupta7/crop-yield-in-indian-states-dataset].  

Response - Yield: The calculated crop yield (production per unit area)

Predictors
* Crop: The name of the cultivated crop .  
* Crop_Year: The year in which the crop was grown.
* Season: The specific cropping season (e.g., Kharif, Rabi, Whole Year).
* State: The Indian state where the crop was cultivated.
* Area: The total land area (in hectares) under cultivation for the specific crop.
* Production: The quantity of crop production (in metric tons).
* Annual_Rainfall: The annual rainfall received in the crop-growing region (in mm).
* Fertilizer: The total amount of fertilizer used for the crop (in kilograms).
* Pesticide: The total amount of pesticide used for the crop (in kilograms).

```{r}
kable(
  head(crops, 5)
)
```

```{r}
levels(crops$Season)
```

```{r}
levels(crops$State)

# See https://en.wikipedia.org/wiki/Administrative_divisions_of_India

states_to_zones = c(
  "Chandigarh" = "Northern",
  "Delhi" = "Northern",
  "Haryana" = "Northern",
  "Himachal Pradesh" = "Northern",
  "Jammu and Kashmir" = "Northern",
  "Ladakh" = "Northern",
  "Punjab" = "Northern",
  "Rajasthan" = "Northern",
  "Assam" = "North Eastern",
  "Arunachal Pradesh" = "North Eastern",
  "Manipur" = "North Eastern",
  "Meghalaya" = "North Eastern",
  "Mizoram" = "North Eastern",
  "Nagaland" = "North Eastern",
  "Tripura" = "North Eastern",
  "Sikkim" = "North Eastern",
  "Chhattisgarh" = "Central",
  "Madhya Pradesh" = "Central",
  "Uttarakhand" = "Central",
  "Uttar Pradesh" = "Central",
  "Bihar" = "Eastern",
  "Jharkhand" = "Eastern",
  "Odisha" = "Eastern",
  "West Bengal" = "Eastern",
  "Goa" = "Western",
  "Gujarat" = "Western",
  "Maharashtra" = "Western",
  "Andhra Pradesh" = "Southern",
  "Karnataka" = "Southern",
  "Kerala" = "Southern",
  "Puducherry" = "Southern",
  "Tamil Nadu" = "Southern",
  "Telangana" = "Southern"
)


crops$State = revalue(crops$State, states_to_zones)
names(crops)[which(names(crops) == "State")] = "Zone"
crops$Zone = as.factor(crops$Zone)
levels(crops$Zone)
```

```{r fig.height=5, fig.width=10}
vars.res = "Production"
vars.con = c("Crop_Year", "Area", "Annual_Rainfall", "Fertilizer", "Pesticide")
vars.cat = c("Crop", "Season", "Zone")
```

## Methods

Starting off, we do some exploration of the data, prepare train and test splits, and address problematic data.  

```{r}
set.seed(0)

nrow(crops)

sample = sample(c(TRUE, FALSE), nrow(crops), replace=TRUE, prob=c(0.8,0.2))
crops.train = crops[sample, ]
crops.test = crops[!sample, ]

nrow(crops.train)
nrow(crops.test)
```

```{r}
pairs(crops.train[, c(vars.con, vars.res)])
```

Next, we create a baseline additive model with all predictors.

```{r fig.height=5, fig.width=8}
baseline = lm(Production ~ ., data = crops.train)
summary(baseline)
plot_fitted_v_actual(baseline)
assumptions_plots(baseline)
plot_cooksd(baseline)
car::vif(baseline)
get_loocv_rmse(baseline)


# TODO: remove add some other candidates, maybe a full additive as a "control"?
# TODO: remove It turns out yield = production / area after looking at the data... seems like a good idea to exclude production?

```

# Todo: Add code to show the influential point and warrant removal

Remove that one super influential point

```{r fig.height=5, fig.width=8}
infl_pt_idx = cooks.distance(baseline) > 4 / nrow(crops.train)
idx_remove = which.max(cooks.distance(baseline))
crops.train.no_infl = crops.train[-idx_remove,]

baseline.no_infl = lm(Production ~ ., data = crops.train.no_infl)
summary(baseline.no_infl)
plot_fitted_v_actual(baseline.no_infl)
assumptions_plots(baseline.no_infl)
plot_cooksd(baseline.no_infl)
# car::vif(baseline.no_infl)
get_loocv_rmse(baseline.no_infl)
```


```{r fig.height=5, fig.width=8}

# See https://www.statology.org/box-cox-transformation-in-r/

# Define plotting area
set_plot_grid(1, 2)

# Box-cox requires that the response be positive (0 doesn't work), so we add
# 1 here (just need to remember to subtract 1 when giving actual predictions)
baseline = lm(I(Production + 1) ~ ., data = crops.train)

bc = boxcox(baseline)
(lambda <- bc$x[which.max(bc$y)])

baseline.bc <- lm(bc_transform(Production, lambda) ~ ., data = crops.train)

assumptions_plots(baseline.bc)

bptest(baseline.bc)
shapiro.test(resid(baseline.bc))
```

***

```{r}
baseline.poly = lm(Production + 1 ~ 
                        (poly(Crop_Year, degree = 2, raw = 1) +
                        poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1)) *
                        (Crop + Season + Zone),
                        data = crops.train)
summary(baseline.poly)
plot_fitted_v_actual(baseline.poly)
assumptions_plots(baseline.poly)
plot_cooksd(baseline.poly)
# car::vif(baseline.poly)
get_loocv_rmse(baseline.poly)
bptest(baseline.poly)
shapiro.test(resid(baseline.poly))
```

```{r}
crops.train.poly.no_infl = remove_infl_pts(baseline.poly, crops.train)

baseline.poly = lm(Production + 1 ~ 
                        (poly(Crop_Year, degree = 2, raw = 1) +
                        poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1)) *
                        (Crop + Season + Zone),
                        data = crops.train.poly.no_infl)
summary(baseline.poly)
plot_fitted_v_actual(baseline.poly)
assumptions_plots(baseline.poly)
plot_cooksd(baseline.poly)
# car::vif(baseline.poly)
get_loocv_rmse(baseline.poly)
bptest(baseline.poly)
shapiro.test(resid(baseline.poly))
```

```{r}
bc = boxcox(baseline.poly)
(lambda <- bc$x[which.max(bc$y)])

baseline.poly.bc = lm(bc_transform(Production + 1, lambda) ~ 
                        (poly(Crop_Year, 2, raw = 1) +
                        poly(Area, 2, raw = 1) +
                        poly(Annual_Rainfall, 2, raw = 1) +
                        poly(Fertilizer, 2, raw = 1) +
                        poly(Pesticide, 2, raw = 1)) *
                        (Crop + Season + Zone),
                        data = crops.train.poly.no_infl)

summary(baseline.poly.bc)
plot_fitted_v_actual(baseline.poly.bc)
assumptions_plots(baseline.poly.bc)
plot_cooksd(baseline.poly.bc)
# car::vif(baseline.poly.bc)
get_loocv_rmse(baseline.poly.bc)
bptest(baseline.poly.bc)
shapiro.test(resid(baseline.poly.bc))
```

***
```{r}
baseline.multi = lm(Production + 1 ~ 
                        (poly(Crop_Year, degree = 2, raw = 1) +
                        poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1) +
                        I(sqrt(Crop_Year)) +
                        I(sqrt(Area)) +
                        I(sqrt(Annual_Rainfall)) +
                        I(sqrt(Fertilizer)) +
                        I(sqrt(Pesticide)) +
                        I(log(Crop_Year)) +
                        I(log(Area)) +
                        I(log(Annual_Rainfall)) +
                        I(log(Fertilizer)) +
                        I(log(Pesticide))) *
                        (Crop + Season + Zone),
                        data = crops.train)
summary(baseline.multi)
plot_fitted_v_actual(baseline.multi)
assumptions_plots(baseline.multi)
plot_cooksd(baseline.multi)
# car::vif(baseline.multi)
get_loocv_rmse(baseline.multi)
bptest(baseline.multi)
shapiro.test(resid(baseline.multi))
```

```{r}
crops.train.multi.no_infl = remove_infl_pts(baseline.multi, crops.train)

baseline.multi = lm(Production + 1 ~ 
                        (poly(Crop_Year, degree = 2, raw = 1) +
                        poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1) +
                        I(sqrt(Crop_Year)) +
                        I(sqrt(Area)) +
                        I(sqrt(Annual_Rainfall)) +
                        I(sqrt(Fertilizer)) +
                        I(sqrt(Pesticide)) +
                        I(log(Crop_Year)) +
                        I(log(Area)) +
                        I(log(Annual_Rainfall)) +
                        I(log(Fertilizer)) +
                        I(log(Pesticide))) *
                        (Crop + Season + Zone),
                        data = crops.train.multi.no_infl)
summary(baseline.multi)
plot_fitted_v_actual(baseline.multi)
assumptions_plots(baseline.multi)
plot_cooksd(baseline.multi)
# car::vif(baseline.multi)
get_loocv_rmse(baseline.multi)
bptest(baseline.multi)
shapiro.test(resid(baseline.multi))
```

```{r}
bc = boxcox(baseline.multi)
(lambda <- bc$x[which.max(bc$y)])

baseline.multi.bc = lm(bc_transform(Production + 1, lambda) ~ 
                        (poly(Crop_Year, degree = 2, raw = 1) +
                        poly(Area, degree = 2, raw = 1) +
                        poly(Annual_Rainfall, degree = 2, raw = 1) +
                        poly(Fertilizer, degree = 2, raw = 1) +
                        poly(Pesticide, degree = 2, raw = 1) +
                        I(sqrt(Crop_Year)) +
                        I(sqrt(Area)) +
                        I(sqrt(Annual_Rainfall)) +
                        I(sqrt(Fertilizer)) +
                        I(sqrt(Pesticide)) +
                        I(log(Crop_Year)) +
                        I(log(Area)) +
                        I(log(Annual_Rainfall)) +
                        I(log(Fertilizer)) +
                        I(log(Pesticide))) *
                        (Crop + Season + Zone),
                        data = crops.train.multi.no_infl)

summary(baseline.multi.bc)
plot_fitted_v_actual(baseline.multi.bc)
assumptions_plots(baseline.multi.bc)
plot_cooksd(baseline.multi.bc)
# car::vif(baseline.multi.bc)
get_loocv_rmse(baseline.multi.bc)
bptest(baseline.multi.bc)
shapiro.test(resid(baseline.multi.bc))
```

***

```{r}
model.aic.backward = step(baseline.poly.bc, direction = "backward", trace = 0)
summary(model.aic.backward)
plot_fitted_v_actual(model.aic.backward)
assumptions_plots(model.aic.backward)
plot_cooksd(model.aic.backward)
# car::vif(model.aic.backward)
get_loocv_rmse(model.aic.backward)
bptest(model.aic.backward)
shapiro.test(resid(model.aic.backward))
```

```{r}
model.bic.backward = step(baseline.poly.bc, direction = "backward", trace = 0, 
                          k = log(nrow(crops.train.poly.no_infl)))
summary(model.bic.backward)
plot_fitted_v_actual(model.bic.backward)
assumptions_plots(model.bic.backward)
plot_cooksd(model.bic.backward)
# car::vif(model.bic.backward)
get_loocv_rmse(model.bic.backward)
bptest(model.bic.backward)
shapiro.test(resid(model.bic.backward))
```


```{r}
f <- as.formula(bc_transform(Production + 1, lambda) ~ 
                        (poly(Crop_Year, degree = 3, raw = 1) +
                        poly(Area, degree = 3, raw = 1) +
                        poly(Annual_Rainfall, degree = 3, raw = 1) +
                        poly(Fertilizer, degree = 3, raw = 1) +
                        poly(Pesticide, degree = 3, raw = 1)) *
                        (Crop + Season + Zone))
y <- crops$Production
x <- (model.matrix(f, crops))
model.lasso.cv = cv.glmnet(x, y, alpha = 1, parallel = 1)
best_lambda = model.lasso.cv$lambda.min
plot(model.lasso.cv)

best_model <- glmnet(x, y, alpha = 1, lambda = best_lambda)
coef(best_model)

summary(best_model)
plot_fitted_v_actual(best_model)
assumptions_plots(best_model)
plot_cooksd(best_model)
# car::vif(best_model)
get_loocv_rmse(best_model)
bptest(best_model)
shapiro.test(resid(best_model))
best_model.
```

