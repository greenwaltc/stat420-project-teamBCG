---
title: "Predicting Grain Crop Yields in India for Years 1997 - 2020"
output: html_document
date: "2023-07-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(plyr)
library(car)
library(glmnet)
library(MASS)
```

## Introduction

Below we will explore our ability to predict yields of grain crops in India based on some information about the land in which they were grown on (field size, general region), the type of grain, inputs used (fertilizer, pesticide), and weather (season, rain).  

```{r message=FALSE}
crops = read_csv("crop_yield.csv")
```


```{r message=FALSE, warning=FALSE}

grains = c( "Amaranth", "Barley", "Bulgur", "Corn", "Farro", "Einkorn", "Emmer",
            "Spelt", "Millet", "Freaked", "Farik", "Durum Wheat", 
            "Khorasan Wheat", "Oats", "Quinoa", "Kana", "Rice", "Rye", 
            "Sorghum", "Teff", "Triticale", "Wheat", "Wild Rice", "Wheat", 
            "Wheat berries", "Hominy", "Spelt", "Rye", "Brown Rice", "Farro", 
            "Emmer", "Barley", "Bran", "Durum Wheat ", "Triticale", 
            "Bulgur Wheat", "Couscous", "Farina", "Kamut", "Orzo", "Semolina", 
            "Graham", "Oats", "Corn", "maize", "Cornflour ", "Cornmeal", "Rice", 
            "Wild Rice", "Teff", "Montina flour", "Sorghum", "Oats", "Freekeh", 
            "Emmer", "Eikorn", "Malt", "Graham", "Couscous", "Polenta", "Muesli", 
            "Seitan", "Panko", "Grain Alcohol", "Atta Flour", "Amaranth", "Quinoa", 
            "Millet", "Barley Malt", "Beer", "Bleached Flour", "Breads", 
            "Baked Goods", "Brown Rice Syrup", "Buckwheat", "Corn Flakes", 
            "Croutons", "Cereals", "Wheat Germ", "Enriched Bleach Flour", 
            "Malted Barley Flour", "Millet", "Granary Flour", "Groats", 
            "Pastas", "Matzo", "Rice Milk", "Seitan", "Tabbouleh", "Udon", 
            "Corn Starch", "Wheat nuts", "Other Cereals"
)

# Other grain types may be added later
crops = crops[str_squish(tolower(crops$Crop)) %in% str_squish(tolower(grains)),]

crops$Crop = as.factor(crops$Crop)
crops$Season = as.factor(crops$Season)
crops$State = as.factor(crops$State)

levels(crops$Crop)

# Drop rows with NA. We are trading rigor for simplicity here.  
crops = na.omit(crops)
```

A quick description of the data, which can be found (here)[https://www.kaggle.com/datasets/akshatgupta7/crop-yield-in-indian-states-dataset].  

Response - Yield: The calculated crop yield (production per unit area)

Predictors
* Crop: The name of the cultivated crop .  
* Crop_Year: The year in which the crop was grown.
* Season: The specific cropping season (e.g., Kharif, Rabi, Whole Year).
* State: The Indian state where the crop was cultivated.
* Area: The total land area (in hectares) under cultivation for the specific crop.
* Production: The quantity of crop production (in metric tons).
* Annual_Rainfall: The annual rainfall received in the crop-growing region (in mm).
* Fertilizer: The total amount of fertilizer used for the crop (in kilograms).
* Pesticide: The total amount of pesticide used for the crop (in kilograms).

```{r}
kable(
  head(crops, 5)
)
```

```{r}
levels(crops$Season)
```

```{r}
levels(crops$State)

# See https://en.wikipedia.org/wiki/Administrative_divisions_of_India

states_to_zones = c(
  "Chandigarh" = "Northern",
  "Delhi" = "Northern",
  "Haryana" = "Northern",
  "Himachal Pradesh" = "Northern",
  "Jammu and Kashmir" = "Northern",
  "Ladakh" = "Northern",
  "Punjab" = "Northern",
  "Rajasthan" = "Northern",
  "Assam" = "North Eastern",
  "Arunachal Pradesh" = "North Eastern",
  "Manipur" = "North Eastern",
  "Meghalaya" = "North Eastern",
  "Mizoram" = "North Eastern",
  "Nagaland" = "North Eastern",
  "Tripura" = "North Eastern",
  "Sikkim" = "North Eastern",
  "Chhattisgarh" = "Central",
  "Madhya Pradesh" = "Central",
  "Uttarakhand" = "Central",
  "Uttar Pradesh" = "Central",
  "Bihar" = "Eastern",
  "Jharkhand" = "Eastern",
  "Odisha" = "Eastern",
  "West Bengal" = "Eastern",
  "Goa" = "Western",
  "Gujarat" = "Western",
  "Maharashtra" = "Western",
  "Andhra Pradesh" = "Southern",
  "Karnataka" = "Southern",
  "Kerala" = "Southern",
  "Puducherry" = "Southern",
  "Tamil Nadu" = "Southern",
  "Telangana" = "Southern"
)

crops$State = revalue(crops$State, states_to_zones)
crops$State = as.factor(crops$State)
levels(crops$State)
```

```{r fig.height=5, fig.width=10}
vars.res = "Yield"
vars.con = c("Crop_Year", "Area", "Production", "Annual_Rainfall", 
                     "Fertilizer", "Pesticide")
vars.cat = c("Crop", "Season", "State")
```

## Methods

Starting off, we do some exploration of the data, prepare train and test splits, and address problematic data.  

```{r}
set.seed(0)
sample = sample(c(TRUE, FALSE), nrow(crops), replace=TRUE, prob=c(0.8,0.2))
crops.train = crops[sample, ]
crops.test = crops[!sample, ]

pairs(crops.train[, c(vars.con, vars.res)])
car::vif(lm(Yield ~ ., data = crops.train))
```


Next, we create some candidate models

```{r}
simple_model = lm(Yield ~ .^2, data = crops.train)
# summary(simple_model)

# TODO: remove add some other candidates, maybe a full additive as a "control"?
# TODO: remove It turns out yield = production / area after looking at the data... seems like a good idea to exclude production?

```

```{r}
simple_model.cooksd = cooks.distance(simple_model)

# These three rows are problematic for some reason. Removing them for now
crops.train = crops.train[!is.na(simple_model.cooksd),]

simple_model = lm(Yield ~ .^2, data = crops.train)
simple_model.cooksd = cooks.distance(simple_model)

simple_model.influential = simple_model.cooksd > (4 / nrow(crops.train))
plot(1:nrow(crops.train), simple_model.cooksd, col = ifelse(simple_model.influential == 1, "red", "black"))
```


```{r}
# We once again trade rigor for simply removing the influential points
crops.train.no_infl = crops.train[!simple_model.influential,]
pairs(crops.train.no_infl[, c(vars.con, vars.res)])
car::vif(lm(Yield ~ ., data = crops.train.no_infl))
```

```{r}

bc_transform = function(x, lambda) {
  (x^lambda-1)/lambda
}

# See https://www.statology.org/box-cox-transformation-in-r/

# Define plotting area
op <- par(pty = "s", mfrow = c(1, 2))

# Box-cox requires that the response be positive (0 doesn't work), so we add
# 1 here (just need to remember to subtract 1 when giving actual predictions)
crops.train.no_infl$Yield = crops.train.no_infl$Yield + 1

simple_model.no_infl = lm(Yield ~ .^2, data = crops.train.no_infl)

qqnorm(simple_model.no_infl$residuals)
qqline(simple_model.no_infl$residuals)

bc = boxcox(simple_model.no_infl)
(lambda <- bc$x[which.max(bc$y)])

new_model <- lm(bc_transform(Yield, lambda) ~ .^2, data = crops.train.no_infl)

qqnorm(new_model$residuals)
qqline(new_model$residuals)

par(op)
```

```{r}
pairs(data.frame(crops.train.no_infl[, c(vars.con)], BC_Yield = bc_transform(crops.train.no_infl$Yield, lambda)))
```


```{r}

```


```{r}
# simple_model = lm(Yield ~ .^2, data = crops[-744,])
# summary(simple_model)
# plot(predict(simple_model, newdata = crops[-744,]), resid(simple_model))
# # length(coef(simple_model))
# 
# which.max(resid(simple_model))
# 
# model.aic.backward = step(simple_model, direction = "backward", trace = 0)
# summary(model.aic.backward)
```

```{r}
# f <- as.formula(Yield ~ .^2)
# y <- crops$Yield
# x <- (model.matrix(f, crops))
# model.lasso.cv = cv.glmnet(x, y, alpha = 1)
# best_lambda = model.lasso.cv$lambda.min
# plot(model.lasso.cv)
# 
# best_model <- glmnet(x, y, alpha = 1, lambda = best_lambda)
# coef(best_model)
```

